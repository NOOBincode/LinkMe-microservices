// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.3
// - protoc             v5.27.1
// source: api/check/v1/check.proto

package check

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationCheckDeleteCheck = "/api.check.v1.Check/DeleteCheck"
const OperationCheckGetCheckById = "/api.check.v1.Check/GetCheckById"
const OperationCheckListChecks = "/api.check.v1.Check/ListChecks"
const OperationCheckSubmitCheck = "/api.check.v1.Check/SubmitCheck"

type CheckHTTPServer interface {
	DeleteCheck(context.Context, *DeleteCheckRequest) (*DeleteCheckReply, error)
	GetCheckById(context.Context, *GetCheckByIdRequest) (*GetCheckByIdReply, error)
	ListChecks(context.Context, *ListChecksRequest) (*ListChecksReply, error)
	SubmitCheck(context.Context, *SubmitCheckRequest) (*SubmitCheckReply, error)
}

func RegisterCheckHTTPServer(s *http.Server, srv CheckHTTPServer) {
	r := s.Route("/")
	r.DELETE("/delete/{checkId}", _Check_DeleteCheck0_HTTP_Handler(srv))
	r.GET("/get/{checkId}", _Check_GetCheckById0_HTTP_Handler(srv))
	r.POST("/list", _Check_ListChecks0_HTTP_Handler(srv))
	r.POST("/submit", _Check_SubmitCheck0_HTTP_Handler(srv))
}

func _Check_DeleteCheck0_HTTP_Handler(srv CheckHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteCheckRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCheckDeleteCheck)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteCheck(ctx, req.(*DeleteCheckRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteCheckReply)
		return ctx.Result(200, reply)
	}
}

func _Check_GetCheckById0_HTTP_Handler(srv CheckHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetCheckByIdRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCheckGetCheckById)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetCheckById(ctx, req.(*GetCheckByIdRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetCheckByIdReply)
		return ctx.Result(200, reply)
	}
}

func _Check_ListChecks0_HTTP_Handler(srv CheckHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListChecksRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCheckListChecks)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListChecks(ctx, req.(*ListChecksRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListChecksReply)
		return ctx.Result(200, reply)
	}
}

func _Check_SubmitCheck0_HTTP_Handler(srv CheckHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SubmitCheckRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationCheckSubmitCheck)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SubmitCheck(ctx, req.(*SubmitCheckRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SubmitCheckReply)
		return ctx.Result(200, reply)
	}
}

type CheckHTTPClient interface {
	DeleteCheck(ctx context.Context, req *DeleteCheckRequest, opts ...http.CallOption) (rsp *DeleteCheckReply, err error)
	GetCheckById(ctx context.Context, req *GetCheckByIdRequest, opts ...http.CallOption) (rsp *GetCheckByIdReply, err error)
	ListChecks(ctx context.Context, req *ListChecksRequest, opts ...http.CallOption) (rsp *ListChecksReply, err error)
	SubmitCheck(ctx context.Context, req *SubmitCheckRequest, opts ...http.CallOption) (rsp *SubmitCheckReply, err error)
}

type CheckHTTPClientImpl struct {
	cc *http.Client
}

func NewCheckHTTPClient(client *http.Client) CheckHTTPClient {
	return &CheckHTTPClientImpl{client}
}

func (c *CheckHTTPClientImpl) DeleteCheck(ctx context.Context, in *DeleteCheckRequest, opts ...http.CallOption) (*DeleteCheckReply, error) {
	var out DeleteCheckReply
	pattern := "/delete/{checkId}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCheckDeleteCheck))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CheckHTTPClientImpl) GetCheckById(ctx context.Context, in *GetCheckByIdRequest, opts ...http.CallOption) (*GetCheckByIdReply, error) {
	var out GetCheckByIdReply
	pattern := "/get/{checkId}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationCheckGetCheckById))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CheckHTTPClientImpl) ListChecks(ctx context.Context, in *ListChecksRequest, opts ...http.CallOption) (*ListChecksReply, error) {
	var out ListChecksReply
	pattern := "/list"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCheckListChecks))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *CheckHTTPClientImpl) SubmitCheck(ctx context.Context, in *SubmitCheckRequest, opts ...http.CallOption) (*SubmitCheckReply, error) {
	var out SubmitCheckReply
	pattern := "/submit"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationCheckSubmitCheck))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
